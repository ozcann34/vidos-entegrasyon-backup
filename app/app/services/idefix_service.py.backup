import base64
import json
import logging
import requests
from typing import List, Dict, Optional, Any
from datetime import datetime

logger = logging.getLogger(__name__)

class IdefixClient:
    """
    Idefix API Client for product inventory and price management.
    """
    
    BASE_URL = "https://merchantapi.idefix.com"
    
    def __init__(self, api_key: str, api_secret: str, vendor_id: str):
        """
        Initialize Idefix API client.
        
        Args:
            api_key: Idefix API Key
            api_secret: Idefix API Secret
            vendor_id: Idefix vendor/seller ID
        """
        self.api_key = api_key
        self.api_secret = api_secret
        self.vendor_id = vendor_id
        self._auth_token = self._generate_auth_token()
        
    def _generate_auth_token(self) -> str:
        """
        Generate auth token for Authorization header.
        
        Using Basic Auth format: base64(ApiKey:ApiSecret)
        """
        # Basic Auth format: base64 encode "key:secret"
        auth_string = f"{self.api_key}:{self.api_secret}"
        logger.info(f"[IDEFIX AUTH] Generating token from Key length: {len(self.api_key)}, Secret length: {len(self.api_secret)}")
        logger.debug(f"[IDEFIX AUTH] Auth string (first 20 chars): {auth_string[:20]}...")
        token = base64.b64encode(auth_string.encode('utf-8')).decode('utf-8')
        logger.debug(f"[IDEFIX AUTH] Encoded token (first 30 chars): {token[:30]}...")
        return token
    
    def _get_headers(self) -> Dict[str, str]:
        """Get default headers for API requests."""
        # Official documentation: X-API-KEY header with base64_encode(ApiKEY:ApiSecret)
        vendor_token = base64.b64encode(f"{self.api_key}:{self.api_secret}".encode('utf-8')).decode('utf-8')
        logger.info(f"[IDEFIX] Using X-API-KEY header with token length: {len(vendor_token)}")
        return {
            'Content-Type': 'application/json',
            'X-API-KEY': vendor_token,
            'Accept': 'application/json'
        }
    
    def update_inventory_and_price(
        self,
        items: List[Dict[str, Any]],
        batch_callback: Optional[callable] = None
            
        Returns:
            Dict containing the API response
            
        Example items format:
        [
            {
                "barcode": "1234567890123",
                "price": 100.0,  # Price in TL (kuruÅŸ)
                "comparePrice": 120.0,  # Original price (kuruÅŸ)
                "inventoryQuantity": 10,
                "deliveryDuration": 1,  # Days
                "deliveryType": "regular"  # "regular" or "fast"
            }
        ]
        """
        url = f"{self.BASE_URL}/pim/catalog/{self.vendor_id}/inventory-upload"
        
        # Convert prices to kuruÅŸ (multiply by 100)
        processed_items = []
        for item in items:
            processed_item = item.copy()
            processed_item['price'] = int(float(item['price']) * 100)
            if 'comparePrice' in item and item['comparePrice']:
                processed_item['comparePrice'] = int(float(item['comparePrice']) * 100)
            else:
                processed_item['comparePrice'] = processed_item['price']
            processed_items.append(processed_item)
        
        payload = {"items": processed_items}
        
        try:
            response = requests.post(
                url,
                headers=self._get_headers(),
                json=payload,
                timeout=30
            )
            
            response.raise_for_status()
            result = response.json()
            
            if batch_callback and 'batchRequestId' in result:
                batch_callback(result['batchRequestId'], result)
                
            return result
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Idefix API request failed: {str(e)}")
            if hasattr(e, 'response') and e.response is not None:
                logger.error(f"Response status: {e.response.status_code}")
                logger.error(f"Response body: {e.response.text}")
            raise
    
    def get_inventory_status(self, batch_request_id: str) -> Dict[str, Any]:
        """
        Get the status of an inventory update batch.
        
        Args:
            batch_request_id: The batch ID from update_inventory_and_price response
            
        Returns:
            Dict containing the batch status and item results
        """
        url = f"{self.BASE_URL}/pim/catalog/{self.vendor_id}/inventory-result/{batch_request_id}"
        
        try:
            response = requests.get(
                url,
                headers=self._get_headers(),
                timeout=30
            )
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to get inventory status: {str(e)}")
            if hasattr(e, 'response') and e.response is not None:
                logger.error(f"Response status: {e.response.status_code}")
                logger.error(f"Response body: {e.response.text}")
            raise

    def get_categories(self, page: int = 0, size: int = 1000) -> Dict[str, Any]:
        """
        Get list of categories from Idefix.
        Endpoint: /pim/product-category
        """
        url = f"{self.BASE_URL}/pim/product-category"
        params = {'page': page, 'size': size}
        try:
            response = requests.get(url, headers=self._get_headers(), params=params, timeout=30)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to get categories: {str(e)}")
            raise

    def fast_list_products(self, products: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Fast List products on Idefix (HÄ±zlÄ± ÃœrÃ¼n Ekleme).
        Endpoint: /pim/catalog/{vendorId}/fast-listing
        
        CRITICAL: Idefix API expects prices in TL (float), NOT kuruÅŸ!
        Documentation: https://developer.idefix.com/api/urun-entegrasyonu/hizli-urun-ekleme
        """
        url = f"{self.BASE_URL}/pim/catalog/{self.vendor_id}/fast-listing"
        
        # Get brand ID from settings
        from app.models import Setting
        brand_id = Setting.get('IDEFIX_BRAND_ID', '')
        
        # NO CONVERSION - Idefix expects TL directly!
        # Example from docs: "price": 20 means 20 TL
        processed = []
        for p in products:
            item = {
                'title': p.get('title'),
                'barcode': p.get('barcode'),
                'vendorStockCode': p.get('vendorStockCode'),
                'price': float(p.get('price', 0)),  # Keep in TL!
                'comparePrice': float(p.get('comparePrice', 0)),  # Keep in TL!
                'inventoryQuantity': int(p.get('inventoryQuantity', 0))
            }
            # Add brandId if available
            if brand_id:
                item['brandId'] = int(brand_id)
            
            processed.append(item)

        payload = {"items": processed}
        
        logger.info(f"[IDEFIX] Sending {len(processed)} products to fast-listing")
        logger.debug(f"[IDEFIX] Payload: {payload}")
        
        try:
            response = requests.post(url, headers=self._get_headers(), json=payload, timeout=60)
            response.raise_for_status()
            result = response.json()
            logger.info(f"[ID EFIX] Success! BatchRequestId: {result.get('batchRequestId')}")
            return result
        except requests.exceptions.RequestException as e:
            logger.error(f"[IDEFIX] Failed to fast list products: {str(e)}")
            if hasattr(e, 'response') and e.response is not None:
                logger.error(f"[IDEFIX] Response status: {e.response.status_code}")
                logger.error(f"[IDEFIX] Response body: {e.response.text}")
            raise
    
    def query_batch_status(self, batch_request_id: str) -> Dict[str, Any]:
        """
        Query the status of a batch request.
        
        Args:
            batch_request_id: The batchRequestId returned from fast_list_products
            
        Returns:
            Dict containing batch status and item details
        """
        url = f"{self.BASE_URL}/pim/catalog/{self.vendor_id}/fast-listing-result/{batch_request_id}"
        
        logger.info(f"[IDEFIX] Querying batch status: {batch_request_id}")
        
        try:
            response = requests.get(url, headers=self._get_headers(), timeout=30)
            response.raise_for_status()
            result = response.json()
            
            # Log summary
            status = result.get('status', 'UNKNOWN')
            items = result.get('items', [])
            logger.info(f"[IDEFIX] Batch status: {status}, Items: {len(items)}")
            
            # Log item states
            for item in items:
                pool_state = item.get('poolState', 'unknown')
                barcode = item.get('barcode', 'N/A')
                logger.info(f"[IDEFIX]   - {barcode}: {pool_state}")
            
            return result
        except requests.exceptions.RequestException as e:
            logger.error(f"[IDEFIX] Failed to query batch status: {str(e)}")
            if hasattr(e, 'response') and e.response is not None:
                logger.error(f"[IDEFIX] Response status: {e.response.status_code}")
                logger.error(f"[IDEFIX] Response body: {e.response.text}")
            raise

def get_idefix_client() -> IdefixClient:
    # HARDCODED FOR TESTING - credentials from email
    api_key = "44d9e992-99bb-4d2c-a71d-dc049496438e"
    api_secret = "babbe6fe-a86a-465d-972e-55b295eecc66"
    vendor_id = "15237"
    
    logger.info(f"[IDEFIX AUTH] HARDCODED - API Key length: {len(api_key)}, Secret length: {len(api_secret)}, Vendor ID: {vendor_id}")
    
    if not api_key or not vendor_id:
        raise ValueError("Idefix API anahtarÄ± ve SatÄ±cÄ± ID gereklidir.")
    
    if not api_secret:
        logger.warning("[IDEFIX AUTH] API SECRET IS EMPTY! This will likely cause 401 errors.")
        
    return IdefixClient(api_key, api_secret, vendor_id)

def perform_idefix_send_products(job_id: str, barcodes: List[str], xml_source_id: Optional[int] = None) -> Dict[str, Any]:
    from app.services.job_queue import append_mp_job_log
    from app.services.xml_service import load_xml_source_index
    from app.utils.helpers import to_float, to_int
    from app.models import BatchLog, Setting
    from app import db
    from flask_login import current_user
    import uuid
    
    append_mp_job_log(job_id, "Ä°defix gÃ¶nderim iÅŸlemi baÅŸlatÄ±lÄ±yor (HÄ±zlÄ± Ekleme)...")
    
    # Create batch log entry
    batch_id = str(uuid.uuid4())
    batch_log = BatchLog(
        batch_id=batch_id,
        marketplace='idefix',
        user_id=current_user.id if hasattr(current_user, 'id') else None,
        product_count=len(barcodes),
        success=False,
        details=json.dumps({'job_id': job_id, 'xml_source_id': xml_source_id})
    )
    db.session.add(batch_log)
    db.session.commit()
    
    append_mp_job_log(job_id, f"Batch Log oluÅŸturuldu: {batch_id}")
    
    try:
        client = get_idefix_client()
    except Exception as e:
        error_msg = f"Ä°defix client hatasÄ±: {str(e)}"
        append_mp_job_log(job_id, error_msg)
        batch_log.success = False
        batch_log.details = json.dumps({'error': error_msg})
        db.session.commit()
        return {"success_count": 0, "fail_count": len(barcodes), "failures": [error_msg]}

    # Load XML Data
    append_mp_job_log(job_id, "XML verisi yÃ¼kleniyor...")
    index = load_xml_source_index(xml_source_id)
    if not index:
        error_msg = "XML verisi okunamadÄ±"
        append_mp_job_log(job_id, error_msg)
        batch_log.success = False
        batch_log.details = json.dumps({'error': error_msg})
        db.session.commit()
        return {"success_count": 0, "fail_count": len(barcodes), "failures": [error_msg]}

    products_to_send = []
    skipped_count = 0
    skipped_list = []

    # Get price multiplier
    try:
        multiplier = float(Setting.get("IDEFIX_PRICE_MULTIPLIER", "1.0", user_id=current_user.id if hasattr(current_user, 'id') else None) or "1.0")
    except:
        multiplier = 1.0

    for barcode in barcodes:
        rec = index.get(str(barcode))
        if not rec:
            skipped_count += 1
            skipped_list.append({'barcode': barcode, 'reason': 'XML\'de bulunamadÄ±'})
            continue

        price = float(rec.get('price', 0))
        final_price = price * multiplier
        
        prod = {
            "barcode": barcode,
            "title": rec.get('title'),
            "vendorStockCode": rec.get('stockCode') or barcode,
            "price": final_price,
            "comparePrice": final_price,
            "inventoryQuantity": int(rec.get('quantity', 0)),
        }
        products_to_send.append(prod)

    if not products_to_send:
        error_msg = "GÃ¶nderilecek Ã¼rÃ¼n bulunamadÄ±"
        append_mp_job_log(job_id, error_msg)
        batch_log.success = False
        batch_log.details = json.dumps({'error': error_msg, 'skipped': skipped_list})
        db.session.commit()
        return {
            "success_count": 0, 
            "fail_count": skipped_count, 
            "failures": [x['reason'] for x in skipped_list[:5]],
            "matched": [],
            "skipped": skipped_list
        }

    # Send products to Ä°defix
    success_count = 0
    fail_count = 0
    failures = []
    batch_request_ids = []
    
    batch_size = 50
    total_batches = (len(products_to_send) + batch_size - 1) // batch_size
    
    for i in range(0, len(products_to_send), batch_size):
        batch = products_to_send[i:i+batch_size]
        batch_num = i//batch_size + 1
        
        append_mp_job_log(job_id, f"Batch {batch_num}/{total_batches} gÃ¶nderiliyor ({len(batch)} Ã¼rÃ¼n)...")
        
        try:
            resp = client.fast_list_products(batch)
            batch_request_id = resp.get('batchRequestId')
            
            if batch_request_id:
                batch_request_ids.append(batch_request_id)
                success_count += len(batch)
                append_mp_job_log(job_id, f"âœ… Batch {batch_num} iletildi. BatchRequestID: {batch_request_id}")
                append_mp_job_log(job_id, f"â³ ÃœrÃ¼nler Ä°defix'te iÅŸleniyor. Durum sorgusu iÃ§in ID kaydedildi.")
            else:
                fail_count += len(batch)
                failures.append(f"Batch {batch_num}: BatchRequestID alÄ±namadÄ±")
                append_mp_job_log(job_id, f"âš ï¸ Batch {batch_num}: ID alÄ±namadÄ±")
                
        except Exception as e:
            error_msg = f"Batch {batch_num} hatasÄ±: {str(e)}"
            fail_count += len(batch)
            failures.append(error_msg)
            append_mp_job_log(job_id, f"âŒ {error_msg}")

    # Update batch log with results
    batch_log.success = success_count > 0
    batch_log.details = json.dumps({
        'job_id': job_id,
        'batch_request_ids': batch_request_ids,
        'success_count': success_count,
        'fail_count': fail_count + skipped_count,
        'failures': failures,
        'skipped': skipped_list
    })
    db.session.commit()
    
    # Log important information about Ä°defix workflow
    if batch_request_ids:
        append_mp_job_log(job_id, "")
        append_mp_job_log(job_id, "ğŸ“‹ Ä°DEFÄ°X SONRAKI ADIMLAR:")
        append_mp_job_log(job_id, "1. ÃœrÃ¼nleriniz Ä°defix tarafÄ±ndan iÅŸleniyor")
        append_mp_job_log(job_id, "2. EÅŸleÅŸme bulunursa onay/red yapmanÄ±z gerekecek")
        append_mp_job_log(job_id, "3. Batch durumunu sorgulamak iÃ§in BatchRequestID'leri saklayÄ±n")
        append_mp_job_log(job_id, f"4. Batch Log ID: {batch_id}")
        append_mp_job_log(job_id, "")
        append_mp_job_log(job_id, "âš ï¸ Ã–NEMLÄ°: Ä°defix'te Ã¼rÃ¼nlerin gÃ¶rÃ¼nmesi iÃ§in:")
        append_mp_job_log(job_id, "   - EÅŸleÅŸme varsa onaylayÄ±n")
        append_mp_job_log(job_id, "   - Yeni Ã¼rÃ¼nler operatÃ¶r onayÄ± bekleyebilir")
        append_mp_job_log(job_id, "   - Batch Logs'dan durumu takip edebilirsiniz")

    return {
        "success_count": success_count,
        "fail_count": fail_count + skipped_count,
        "failures": failures,
        "matched": [p['barcode'] for p in products_to_send],
        "skipped": skipped_list,
        "batch_request_ids": batch_request_ids,
        "batch_id": batch_id
    }
